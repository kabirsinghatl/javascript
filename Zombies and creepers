/***///
/*

I'm doing cool things


you may not rest now, there are monsters nearby


#CodeAtHome

1000 kelvin on 4/27/20 at 48 votes
r.i.p. 1000 kelvin, we will remember you :'(



sub if u want
https://www.khanacademy.org/computer-programming/subscribe-to-xacer/6668371993051136
*/

enableContextMenu();

var setLoopTimeout = function (val) {
	this[["KAInfiniteLoopSetTimeout"]](val);
};
setLoopTimeout(Infinity);

var bccol = [62, 172, 212];

var externals;

// Huge thanks to Quantum Coding for helping make the textures!
// Also huge thanks to Kruxe for making the creeper texture :D

// grass = 0
// wood = 1
// leaf = 2
// dirt = 3
// stone = 4
// bedrock = 5
// planks = 6
// glass = 7
var allTextures = (function () {
	var texmaps = [];
	
	// code to generate the wood texture
	texmaps.push([]);
	for (var y = 0; y < 16 * 3; y++) {
		for (var x = 0; x < 16; x++) {
			var col = 0xff675231;
			var br = 255 - ((random(1) * 96));
			if (x > 0 && x < 15 && ((y > 0 && y < 15) || (y > 32 && y < 47))) {
				col = 0xffBC9862;
				var xd = (x - 7);
				var yd = ((y & 15) - 7);
				if (xd < 0) { 
					xd = 1 - xd;
				}
				if (yd < 0) {
					yd = 1 - yd;
				}
				if (yd > xd){
					xd = yd;
				}

				br = 196 - ((random(1) * 32) | 0) + xd % 3 * 32;
			} else if (((random(1) * 2) | 0) === 0) {
				br = br * (150 - (x & 1) * 100) / 100;
			}
			if (y >= 32) {
				br *= 0.75;
			}
			var col = color(red(col) * br / 255, green(col) * br / 255, blue(col) * br / 255);
			texmaps[texmaps.length - 1][x + y * 16] = col;
		}
	}
	
	// code to generate leaf
	texmaps.push([]);
	for (var y = 0; y < 16 * 3; y++) {
		for (var x = 0; x < 16; x++) {
			var col = 0xff50D937;
			var br = 255 - ((random(1) * 96));
            if (((random(1) * 2) | 0) === 0) {
                col = 0x00ffffff;
                br = 255;
            }
			var col = color(red(col) * br / 255, green(col) * br / 255, blue(col) * br / 255, alpha(col));
			texmaps[texmaps.length - 1][x + y * 16] = col;
		}
	}
	
	// Huge thanks to Quantum Coding for these textures:
	var bitmaps = {};
	var palettes = {};
	//grass block
	bitmaps.grass_side = [
		// 16x16
		"2233221223123423",
		"2311182230032332",
		"0804281822008438",
		"8&88388838287887",
		"67658677888&7687",
		"7866768887787775",
		"5877977557557676",
		"5755667768667766",
		"6776767876677787",
		"6687788777775576",
		"6675575685576697",
		"67766576&6678678",
		"7867665777777755",
		"7677876678587566",
		"6785787877787766",
		"6756679666776678"
	];
	bitmaps.grass_top = [
		// 16x16
		"0332221312333232",
		"1022223233011322",
		"3103002202232211",
		"0133010310303231",
		"1030311030330311",
		"3203030232230022",
		"2222233103302133",
		"2020323130321223",
		"3312121132233031",
		"1020333302111222",
		"1113332300331020",
		"0222302132113330",
		"2332223012112122",
		"0123020312133023",
		"2103030233222210",
		"0120233233230311"
		
	];
	palettes.grass = {
		// transparent
		"-": color(255, 255, 255, 0),
		
		// green
		"0": color(100, 200, 100),
		"1": color(80, 180, 80),
		"2": color(60, 160, 60),
		"3": color(40, 140, 40),
		"4": color(20, 120, 20),
		
		// brown
		"5": color(191, 135, 86),
		"6": color(152, 99, 65),
		"7": color(115, 75, 49),
		"8": color(91, 56, 36),
		
		// gray
		"9": color(137, 141, 142),
		"&": color(103, 105, 104)
	};
	bitmaps.dirt = [
		// 16x16
		"5667756667877575",
		"7687769857785688",
		"5778577566778857",
		"6&57685756767587",
		"67658677888&7687",
		"7866768887787775",
		"5877977557557676",
		"5755667768667766",
		"6776767876677787",
		"6687788777775576",
		"6675575685576697",
		"67766576&6678678",
		"7867665777777755",
		"7677876678587566",
		"6785787877787766",
		"6756679666776678"	 
	];
	palettes.dirt = {
		// transparent
		"-": color(255, 255, 255, 0),
		
		// green
		"0": color(100, 200, 100),
		"1": color(80, 180, 80),
		"2": color(60, 160, 60),
		"3": color(40, 140, 40),
		"4": color(20, 120, 20),
		
		// brown
		"5": color(191, 135, 86),
		"6": color(152, 99, 65),
		"7": color(115, 75, 49),
		"8": color(91, 56, 36),
		
		// gray
		"9": color(137, 141, 142),
		"&": color(103, 105, 104)
	};
	bitmaps.stone = [
		// 16x16
		"2333321141233332",
		"2211112221114223",
		"2422322213222122",
		"2122232122333332",
		"2113333333111114",
		"3322233324223342",
		"1122231122221114",
		"2223333334333322",
		"2114132221111111",
		"2333333242233312",
		"2213311343111222",
		"4222322211222114",
		"2333333311333332",
		"2111112333432211",
		"2223321141233332",
		"3333411222233322",
	];
	palettes.stone = {
		//greys
		"1":color(145, 145, 145),
		"2":color(125,125,125),
		"3": color(115, 115, 115),
		"4": color(105, 105, 105)
	};
	bitmaps.bedrock = [
		// 16x16
		"2333321141233332",
		"2211112221114223",
		"2422322213222122",
		"2122232122333332",
		"2113333333111114",
		"3322233324223342",
		"1122231122221114",
		"2223333334333322",
		"2114132221111111",
		"2333333242233312",
		"2213311343111222",
		"4222322211222114",
		"2333333311333332",
		"2111112333432211",
		"2223321141233332",
		"3333411222233322",
	];
	palettes.bedrock = {
		//greys
		"1":color(150, 150, 150),
		"2":color(85,85,85),
		"3": color(50,50,50),
		"4": color(10, 10, 10)
	};
	bitmaps.planks = [
		// 16x16
		"1222211321111112",
		"1135332222232312",
		"1122221151131112",
		"4445555555444455",
		"1222211212253331",
		"2253331233332222",
		"1113111222111111",
		"5544444555444455",
		"1111152113331112",
		"2222213322251222",
		"1333112222333332",
		"5455444555554445",
		"1111121225223111",
		"3251111213322223",
		"1122211211231111",
		"5555544545546445",
	];
	palettes.planks = {
		// browns
		"1": color(196, 172, 115),
		"2": color(168, 142, 82),
		"3": color(184, 161, 107),
		"4": color(107, 87, 45),
		"5": color(122, 99, 54),
		"6": color(107, 87, 45)
	};
	bitmaps.glass = [
		// 16x16
		"3333333333333311",
		"3              1",
		"3   1          2",
		"3  1           2",
		"3 2            2",
		"3              3",
		"3              2",
		"3              3",
		"3              3",
		"3              3",
		"3              3",
		"3              3",
		"1            1 3",
		"3           1  3",
		"1              1",
		"1121222222222211",
	];
	palettes.glass = {
		"1": color(159, 194, 209),
		"2": color(109, 144, 158),
		"3": color(205, 239, 250),
		" ": color(255, 0),
	};
	
	// Adds the blocks that are the same on all sides
	var allsides = [
		"dirt",
		"stone",
		"bedrock",
		"planks",
		"glass"
	];
	for (var i = 0; i < allsides.length; i ++) {
		texmaps.push([]);
		for (var x = 0; x < 16; x ++) {
			for (var y = 0; y < 16 * 3; y ++) {
				var ry = y % 16;
				var l = x + y * 16;
				var v = bitmaps[allsides[i]][ry][x];
				var c = palettes[allsides[i]][v];
				if (y < 16 * 2 || allsides[i] === "glass") {
					texmaps[texmaps.length - 1][l] = c;
				} else {
					texmaps[texmaps.length - 1][l] = color(red(c) * 0.75, green(c) * 0.75, blue(c) * 0.75);
				}
			}
		}
	}
	
	// Adds grass
	var grassthings = [
		"grass_top",
		"grass_side",
		"dirt",
	];
	texmaps.unshift([]);
	for (var i = 0; i < grassthings.length; i ++) {
		var touse = bitmaps[grassthings[i]];
		for (var x = 0; x < 16; x ++) {
			for (var y = 0; y < 16; y ++) {
				var l = x + y * 16 + i * 16 * 16;
				texmaps[0][l] = palettes.grass[touse[y][x]];
			}
		}
	}
	
	return texmaps;
}) ();

// Each texture has 3 parts: top, sides, bottom

var res = 100;

var viewDistance = 30;

var N = 30;

var xSiz = 50;
var ySiz = 50;
var zSiz = 20;

var sprites = [];

var keys = {};
keyPressed = function () {
	keys[key.toString()] = true;
};
keyReleased = function () {
	keys[key.toString()] = false;
};

var cam = {
	x: 0,
	y: 0,
	z: zSiz - 7.5,
	
	rotXY: Math.PI / 4,
	rotZ: Math.PI/ 8
};

var zvel = 0;

var world = [];

for (var x = 0; x < xSiz; x ++) {
	world[x] = [];
	for (var y = 0; y < ySiz; y ++) {
		world[x][y] = [];
		for (var z = 0; z < zSiz; z ++) {
			world[x][y][z] = {
				value: 0,
				brightness: 0.0,
				sprites: []
			};
		}
	}
}

for (var x = 0; x < xSiz; x ++) {
	for (var y = 0; y < ySiz; y ++) {
		world[x][y][zSiz - 2].value = 2;
		var n = noise(x / N * 2, y / N * 2);
		if (n < 0.45 && Math.random() < 0.2) {
			world[x][y][zSiz - 3].value = 4;
		} else if (n < 0.50) {
			world[x][y][zSiz - 3].value = 1;
		} else {
			world[x][y][zSiz - 3].value = 4;
			world[x][y][zSiz - 4].value = 1;
		}
	}
}

for (var x = 10; x < xSiz; x += 5) {
	for (var y = 0; y < ySiz; y += 5) {
		if (Math.random() < 0.5) {
			continue;
		}
		
		var tx = x + Math.floor(Math.random(5));
		var ty = y + Math.floor(Math.random(5));
		
		for (var z = zSiz - 8; z < zSiz - 3; z ++) {
			world[tx][ty][z].value = 2;
		}
		
		for (var rx = -1; rx <= 1; rx ++) {
			if (tx + rx < 0 || tx + rx > xSiz - 1) {
				continue;
			}
			for (var ry = -1; ry <= 1; ry ++) {
				if (ty + ry < 0 || ty + ry > ySiz - 1) {
					continue;
				}
				for (var rz = -1; rz <= 1; rz ++) {
					var ev = world[tx+rx][ty+ry][rz+zSiz-8].value;
					if (ev !== 2) {
						world[tx+rx][ty+ry][rz+zSiz-8].value = 3;
					}
				}
			}
		}
	}
}

world.inside = function (x, y, z) {
	if (x < 0 || y < 0 || z < 0 || x > xSiz - 1 || y > ySiz - 1 || z > zSiz - 1) {
		return 0;
	}
	return 1;
};
world.getValueAt = function (x, y, z) {
	if (this.inside(x, y, z)) {
		return this[x][y][z].value;
	}
	return 0;
};
world.getLightAt = function (x, y, z) {
	if (world.inside(x, y, z)) {
		return this[x][y][z].brightness;
	}
	return 0;
};
world.destroyBlock = function (x, y, z) {
	if (this.inside(x, y, z)) {
		this[x][y][z].value = 0;
		this[x][y][z].brightness = 0;
		if (x > 0) {
			if (this[x-1][y][z].brightness - 1 > this[x][y][z].brightness) {
				this[x][y][z].brightness = this[x-1][y][z].brightness - 1;
			}
		}
		if (x < xSiz - 1) {
			if (this[x+1][y][z].brightness - 1 > this[x][y][z].brightness) {
				this[x][y][z].brightness = this[x+1][y][z].brightness - 1;
			}
		}
		if (y > 0) {
			if (this[x][y-1][z].brightness - 1 > this[x][y][z].brightness) {
				this[x][y][z].brightness = this[x][y-1][z].brightness - 1;
			}
		}
		if (y < ySiz - 1) {
			if (this[x][y+1][z].brightness - 1 > this[x][y][z].brightness) {
				this[x][y][z].brightness = this[x][y+1][z].brightness - 1;
			}
		}
		if (z > 0) {
			if (this[x][y][z-1].brightness - 1 > this[x][y][z].brightness) {
				this[x][y][z].brightness = this[x][y][z-1].brightness - 1;
			}
		}
		if (z < zSiz - 1) {
			if (this[x][y][z+1].brightness - 1 > this[x][y][z].brightness) {
				this[x][y][z].brightness = this[x][y][z+1].brightness - 1;
			}
		}
	}
};

var SpriteDesigner = (function () {
	var SpriteMap = function (dX, dY, dZ, bSize) {
		this.dX = dX;
		this.dY = dY;
		this.dZ = dZ;
		this.bSize = bSize || 0.05;
		this.arr = [];
		this.arr.length = dX * dY * dZ;
		for (var i = 0; i < this.arr.length; i ++) {
			this.arr[i] = color(255);
		}
	};	
	SpriteMap.prototype.inside = function (x, y, z) {
		return x >= 0 && y >= 0 && z >= 0 && x < this.dX && y < this.dY && z < this.dZ;
	};
	SpriteMap.prototype.getPixel = function (x, y, z) {
		if (!this.inside(x, y, z)) {
			return 0;
		}
		return this[x + (y + z * this.dY) * this.dX];
	};
	SpriteMap.prototype.setPixel = function (x, y, z, c) {
		if (!this.inside(x, y, z)) {
			return 0;
		}
		this[x + (y + z * this.dY) * this.dX] = c;
	};
	SpriteMap.prototype.setRect = function (x, y, z, xd, yd, zd, c) {
		for (var ix = x; ix < x + xd; ix ++) {
			if (ix < 0 || ix >= this.dX) {
				continue;
			}
			for (var iy = y; iy < y + yd; iy ++) {
				if (iy < 0 || iy >= this.dY) {
					continue;
				}
				for (var iz = z; iz < z + zd; iz ++) {
					if (iz < 0 || iz >= this.dZ) {
						continue;
					}
					this.setPixel(ix, iy, iz, c);
				}
			}
		}
	};
	SpriteMap.prototype.setRect2 = function (x, y, z, xd, yd, zd, c) {
		var mode = 0;
		if (xd > yd) {
			if (xd > zd) {
				mode = 0;
			} else {
				mode = 2;
			}
		} else {
			if (yd >= zd) {
				mode = 1;
			} else {
				mode = 2;
			}
		}
		for (var ix = x; ix < x + xd; ix ++) {
			if (ix < 0 || ix >= this.dX) {
				continue;
			}
			for (var iy = y; iy < y + yd; iy ++) {
				if (iy < 0 || iy >= this.dY) {
					continue;
				}
				for (var iz = z; iz < z + zd; iz ++) {
					if (iz < 0 || iz >= this.dZ) {
						continue;
					}
					/*
					var amt = Math.random() / 5;
					if (Math.random() > 0.5) {
						this.setPixel(ix, iy, iz, lerpColor(c, 0xff000000, amt));
					} else {
						this.setPixel(ix, iy, iz, lerpColor(c, 0xffffffff, amt));
					}*/
					var n;
					if (mode === 0) {
						n = noise(ix / 10, iy / 20, iz / 20);
					} else if (mode === 1) {
						n = noise(ix / 20, iy / 10, iz / 20);
					} else {
						n = noise(ix / 20, iy / 20, iz / 10);
					}
					n = map(n, 0, 1, -0.8, 0.8);
					if (n < 0) {
						this.setPixel(ix, iy, iz, lerpColor(c, 0xff000000, -n));
					} else {
						this.setPixel(ix, iy, iz, lerpColor(c, 0xffffffff, +n));
					}
				}
			}
		}
	};
	return {
		create: function (dX, dY, dZ) {
			var obj = Object.create(SpriteMap.prototype);
			return SpriteMap.apply(obj, arguments), obj;
		},
	};
}) ();

var Sprite = (function () {
	var spriteMaps = {};
	
	// Create torch map
	spriteMaps.torch = SpriteDesigner.create(2, 2, 8, 0.05);
	spriteMaps.torch.setRect(0, 0, 2, 1, 1, 6, color(171, 98, 9));
	spriteMaps.torch.setRect(1, 1, 2, 1, 1, 6, color(171, 98, 9));
	
	spriteMaps.torch.setRect(0, 1, 2, 1, 1, 6, color(138, 77, 8));
	spriteMaps.torch.setRect(1, 0, 2, 1, 1, 6, color(138, 77, 8));
	
	spriteMaps.torch.setRect(0, 0, 0, 1, 1, 1, color(232, 165, 65));
	spriteMaps.torch.setRect(1, 1, 0, 1, 1, 1, color(232, 165, 65));
	spriteMaps.torch.setRect(0, 1, 1, 1, 1, 1, color(232, 165, 65));
	spriteMaps.torch.setRect(1, 0, 1, 1, 1, 1, color(232, 165, 65));
	
	spriteMaps.torch.setRect(0, 0, 1, 1, 1, 1, color(230, 197, 67));
	spriteMaps.torch.setRect(1, 1, 1, 1, 1, 1, color(230, 197, 67));
	spriteMaps.torch.setRect(0, 1, 0, 1, 1, 1, color(230, 197, 67));
	spriteMaps.torch.setRect(1, 0, 0, 1, 1, 1, color(230, 197, 67));
	
	spriteMaps.zombie = SpriteDesigner.create(16, 8, 32, 2 / 32);
	var skincol = color(7, 133, 22);
	var shirtcol = color(19, 214, 214);
	var pantscol = color(85, 39, 209);
	var footcol = color(135, 135, 135);
	// Base
	spriteMaps.zombie.setRect2(4, 0, 0, 8, 8, 8, skincol);
	spriteMaps.zombie.setRect2(0, 2, 8, 16, 4, 12, shirtcol);
	spriteMaps.zombie.setRect2(0, 2, 12, 4, 4, 10, skincol);
	spriteMaps.zombie.setRect2(12, 2, 12, 4, 4, 10, skincol);
	spriteMaps.zombie.setRect2(4, 2, 20, 8, 4, 12, pantscol);
	spriteMaps.zombie.setRect2(10, 5, 20, 2, 1, 1, shirtcol);
	spriteMaps.zombie.setRect2(11, 5, 21, 1, 1, 1, shirtcol);
	
	spriteMaps.creeper = SpriteDesigner.create(8, 8, 26, 2 / 26);
	var creeper = {
		palette: {
			0: [0, 0, 0],
			1: [204, 255, 206],
			2: [85, 201, 65],
			3: [87, 255, 98],
			4: [89, 230, 53],
			5: [13, 87, 0],
			6: [0, 224, 52],
			7: [0, 153, 18],
			8: [65, 181, 45],
			9: [110, 173, 97],
			"x": [0, 255, 0],
			"#": [114, 179, 124],
			"o": [22, 56, 0],
			"^": [140, 203, 127],
			" ": [0, 0, 0]
		},
		bitmap: [
			"34231627",
			"73267681",
			"20038001",
			"20547503",
			"39355173",
			"975005x1",
			"19000069",
			"43043074",
			" ^42375 ",
			" ^48#59 ",
			" 82#591 ",
			" 374263 ",
			" 263762 ",
			" 187746 ",
			" 398217 ",
			" 294862 ",
			" 476729 ",
			" 831#24 ",
			" 384668 ",
			" 389762 ",
			"8x228x22",
			"88218821",
			"72347234",
			"39343934",
			"5o5o5o5o",
			"o5o5o5o5"
		],
		sidebitmap: [
			"34231627",
			"73267681",
			"28638231",
			"23547523",
			"39355173",
			"97522521",
			"19846569",
			"43043074",
			"1^423754",
			"3^48#597",
			"2482#591",
			"63742636",
			"^2637629",
			"21877462",
			"13982171",
			"78294862",
			"94767291",
			"1831#245",
			"73846684",
			"43897622",
			"8x228x22",
			"88218821",
			"72347234",
			"39343934",
			"5o5o5o5o",
			"o5o5o5o5"
		],
	};
	for (var iz = 0; iz < 26; iz ++) {
		for (var iy = 0; iy < 8; iy ++) {
			for (var ix = 0; ix < 8; ix ++) {
				var val = creeper.bitmap[iz][iy];
				if (ix !== 0 && ix !== 7) {
					val = creeper.sidebitmap[iz][ix];
				}
				var col = creeper.palette[val];
				if (val !== " ") {
					spriteMaps.creeper.setRect(iy, ix, iz, 1, 1, 1, color(col[0], col[1], col[2]));
				}
			}
		}
	}
	
	var allSprites = [];
	
	/*
	Sprites are measured from the x/y center and the z bottom
	*/
	
	var Sprite = function (x, y, z, name, xyrot) {
		this.x = x;
		this.y = y;
		this.z = z;
		
		this.bSize = spriteMaps[name].bSize;
		
		this.name = name;
		this.map = spriteMaps[name];
		
		this.xyRot = xyrot || 0;
		this.xyCt = Math.cos(this.xyRot);
		this.xySt = Math.sin(this.xyRot);
		
		this.zRot = 0;
		this.zCt = Math.cos(this.zRot);
		this.zSt = Math.sin(this.zRot);
	};
	Sprite.prototype.setAngle = function (theta) {
		this.xyRot = theta;
		this.xyCt = Math.cos(this.xyRot);
		this.xySt = Math.sin(this.xyRot);
	};
	Sprite.prototype.setMap = function () {
		var bSize = this.bSize;
		this.index = allSprites.indexOf(this);
		// Get box
		var xyBox = [
			[-this.map.dX / 2 * bSize, -this.map.dY / 2 * bSize],
			[-this.map.dX / 2 * bSize, +this.map.dY / 2 * bSize],
			[+this.map.dX / 2 * bSize, +this.map.dY / 2 * bSize],
			[+this.map.dX / 2 * bSize, -this.map.dY / 2 * bSize],
		];
		// Rotate coords
		
		// Get max/min on x/y
		var xmin = 99;
		var xmax = -99;
		var ymin = 99;
		var ymax = -99;
		for (var i = 0; i < xyBox.length; i ++) {
			var ox = xyBox[i][0], oy = xyBox[i][1];
			xyBox[i][0] = this.xyCt * ox - this.xySt * oy;
			xyBox[i][1] = this.xySt * ox + this.xyCt * oy;
			xmin = Math.min(xmin, xyBox[i][0]);
			xmax = Math.max(xmax, xyBox[i][0]);
			ymin = Math.min(ymin, xyBox[i][1]);
			ymax = Math.max(ymax, xyBox[i][1]);
		}
		// Set world
		xmin = Math.floor(xmin + this.x);
		xmax = Math.ceil(xmax + this.x);
		ymin = Math.floor(ymin + this.y);
		ymax = Math.ceil(ymax + this.y);
		var zmin = Math.floor(this.z - this.map.dZ * bSize);
		var zmax = Math.ceil(this.z);
		var ix, iy, iz;
		for (ix = xmin; ix < xmax; ix ++) {
			for (iy = ymin; iy < ymax; iy ++) {
				for (iz = zmin; iz < zmax; iz ++) {
					if (world.inside(ix, iy, iz)) {
						world[ix][iy][iz].sprites[0] = this.index;
					}
				}
			}
		}
	};
	Sprite.prototype.castRay = function (hitX, hitY, hitZ, rayDirX, rayDirY, rayDirZ) {
		var bSize = this.bSize;
		// Get relative coords
		var dx = hitX - this.x;
		var dy = hitY - this.y;
		var dz = hitZ - this.z;
		
		// Scale position
		dx *= 1 / bSize;
		dy *= 1 / bSize;
		dz *= 1 / bSize;
		
		
		//println(dx + ', ' + dy + ',' + dz);
		
		// Rotate by -xyRot
		var ox = dx, oy = dy;
		dx = this.xyCt * ox - this.xySt * oy;
		dy = this.xyCt * oy + this.xySt * ox;
		
		var ordx = rayDirX, ordy = rayDirY;
		rayDirX = this.xyCt * ordx - this.xySt * ordy;
		rayDirY = this.xyCt * ordy + this.xySt * ordx;
		
		// Rotate by zRot
		// right now zRot = 0 sooo
		
		// Translate to corner
		dx += this.map.dX / 2;
		dy += this.map.dY / 2;
		dz += this.map.dZ;
		
		
		// Raycast
		var mapX = Math.floor(dx);
		var mapY = Math.floor(dy);
		var mapZ = Math.floor(dz);
		
		var curBlock = this.map.getPixel(mapX, mapY, mapZ);
		if (curBlock) {
			return curBlock;
		}
		
		if (mapX < 0 && rayDirX < 0) {
			return false;
		}
		if (mapX >= this.dX && rayDirY > 0) {
			return false;
		}
		if (mapY < 0 && rayDirY < 0) {
			return false;
		}
		if (mapY >= this.dY && rayDirY > 0) {
			return false;
		}
		if (mapZ < 0 && rayDirZ < 0) {
			return false;
		}
		if (mapZ >= this.dZ && rayDirZ > 0) {
			return false;
		}
		
		var deltaDistX = Math.abs(1 / rayDirX);
		var deltaDistY = Math.abs(1 / rayDirY);
		var deltaDistZ = Math.abs(1 / rayDirZ);
		
		var sideDistX, sideDistY, sideDistZ;
		var stepX, stepY, stepZ;
		if (rayDirX < 0) {
			stepX = -1;
			sideDistX = (dx - mapX) * deltaDistX;
		} else {
			stepX = +1;
			sideDistX = (mapX + 1.0 - dx) * deltaDistX;
		}
		
		if (rayDirY < 0) {
			stepY = -1;
			sideDistY = (dy - mapY) * deltaDistY;
		} else {
			stepY = +1;
			sideDistY = (mapY + 1.0 - dy) * deltaDistY;
		}
		
		if (rayDirZ < 0) {
			stepZ = -1;
			sideDistZ = (dz - mapZ) * deltaDistZ;
		} else {
			stepZ = +1;
			sideDistZ = (mapZ + 1.0 - dz) * deltaDistZ;
		}
		
		var iters = 0;
		var side = 0;
		while (true) {
			if (!this.map.inside(mapX, mapY, mapZ)) {
				if (mapX < 0 && rayDirX < 0) {
					return false;
				}
				if (mapX >= this.dX && rayDirY > 0) {
					return false;
				}
				if (mapY < 0 && rayDirY < 0) {
					return false;
				}
				if (mapY >= this.dY && rayDirY > 0) {
					return false;
				}
				if (mapZ < 0 && rayDirZ < 0) {
					return false;
				}
				if (mapZ >= this.dZ && rayDirZ > 0) {
					return false;
				}
				
			} else {
				var v = this.map.getPixel(mapX, mapY, mapZ);
				if (v) {
					if (side === 0) {
						return lerpColor(v, 0xff000000, 0.30);
					} else if (side === 1) {
						return lerpColor(v, 0xff000000, 0.15);
					} else {
						return v;
					}
				}
			}
			if (iters++ > 200) {
				return false;
			}
			if (sideDistY < sideDistX) {
				if (sideDistZ < sideDistY) {
					mapZ += stepZ;
					sideDistZ += deltaDistZ;
					side = 2;
				} else {
					mapY += stepY;
					sideDistY += deltaDistY;
					side = 1;
				}
			} else {
				if (sideDistZ < sideDistX) {
					mapZ += stepZ;
					sideDistZ += deltaDistZ;
					side = 2;
				} else {
					mapX += stepX;
					sideDistX += deltaDistX;
					side = 0;
				}
			}
		}
	};
	
	return {
		create: function () {
			var obj = Object.create(Sprite.prototype);
			Sprite.apply(obj, arguments);
			allSprites.push(obj);
			obj.setMap();
			return obj;
		},
		sprites: allSprites
	};
}) ();

var addSpriteOnGround = function (x, y, name, rot) {
	var tz = 2;
	while (true) {
		tz ++;
		if (world[Math.floor(x)][Math.floor(y)][tz].value > 0) {
			Sprite.create(x, y, tz, name, rot);
			return;
		}
		if (tz > zSiz - 1) {
			Sprite.create(x, y, tz, name, rot);
			return;
		}
	}
};

addSpriteOnGround(5, 5, "zombie", Math.random() * Math.PI * 2);
addSpriteOnGround(3, 7.5, "zombie", Math.random() * Math.PI * 2);
addSpriteOnGround(9.5, 4, "zombie", Math.random() * Math.PI * 2);
addSpriteOnGround(7, 8.5, "creeper", Math.PI / 4);
addSpriteOnGround(3, 5.5, "creeper", Math.PI / 4);
addSpriteOnGround(5, 3.5, "creeper", Math.PI / 4);
addSpriteOnGround(8, 5.5, "creeper", Math.PI / 4);
var floodFill = [];
var addNeighbor = function (x, y, z, br) {
	if (!world.inside(x, y, z)) {
		return;
	}
	var wv = world.getValueAt(x, y, z);
	if (wv !== 0 && wv !== 3 && wv !== 8) {
		return;
	}
	var nbr = world.getLightAt(x, y, z);
	if (nbr > br - 1) {
		return;
	}
	floodFill.push([x, y, z, br]);
};

var calculateFloodFill = function (lx, ly, lz, intensity) {
	lx = Math.floor(lx);
	ly = Math.floor(ly);
	lz = Math.floor(lz);
	floodFill.length = 0;
	floodFill.push([lx, ly, lz, intensity]);
	while (floodFill.length) {
		var element = floodFill.pop();
		var ex = element[0], ey = element[1], ez = element[2];
		world[element[0]][element[1]][element[2]].brightness = element[3];
		addNeighbor(ex+1, ey, ez, element[3] - 1);
		addNeighbor(ex-1, ey, ez, element[3] - 1);
		addNeighbor(ex, ey+1, ez, element[3] - 1);
		addNeighbor(ex, ey-1, ez, element[3] - 1);
		addNeighbor(ex, ey, ez+1, element[3] - 1);
		addNeighbor(ex, ey, ez-1, element[3] - 1);
	}	
};

var calculateSunFloodFill = function (intensity) {
	floodFill.length = 0;
	for (var x = 0; x < xSiz; x ++) {
		for (var y = 0; y < ySiz; y ++) {
			floodFill.push([x, y, 0, intensity]);
		}
	}
	while (floodFill.length) {
		var element = floodFill.pop();
		var ex = element[0], ey = element[1], ez = element[2];
		world[element[0]][element[1]][element[2]].brightness = element[3];
		addNeighbor(ex+1, ey, ez, element[3] - 1);
		addNeighbor(ex-1, ey, ez, element[3] - 1);
		addNeighbor(ex, ey+1, ez, element[3] - 1);
		addNeighbor(ex, ey-1, ez, element[3] - 1);
		addNeighbor(ex, ey, ez+1, element[3]);
		addNeighbor(ex, ey, ez-1, element[3] - 1);
	}
};

calculateFloodFill(10, 5, zSiz - 8, 20);
calculateFloodFill(5, 10, zSiz - 8, 20);
calculateFloodFill(20, 10, zSiz - 8, 20);
calculateFloodFill(20, 20, zSiz - 8, 20);

var renderRay = function(rayDirX, rayDirY, rayDirZ) {
	var mapX = Math.floor(cam.x);
	var mapY = Math.floor(cam.y);
	var mapZ = Math.floor(cam.z);
	
	var sideDistX, sideDistY, sideDistZ;

	var deltaDistX = Math.abs(1 / rayDirX);
	var deltaDistY = Math.abs(1 / rayDirY);
	var deltaDistZ = Math.abs(1 / rayDirZ);

	var stepX, stepY, stepZ;
	
	if (rayDirX < 0) {
		stepX = -1;
		sideDistX = (cam.x - mapX) * deltaDistX;
	} else {
		stepX = +1;
		sideDistX = (mapX + 1.0 - cam.x) * deltaDistX;
	}
	
	if (rayDirY < 0) {
		stepY = -1;
		sideDistY = (cam.y - mapY) * deltaDistY;
	} else {
		stepY = +1;
		sideDistY = (mapY + 1.0 - cam.y) * deltaDistY;
	}
	
	if (rayDirZ < 0) {
		stepZ = -1;
		sideDistZ = (cam.z - mapZ) * deltaDistZ;
	} else {
		stepZ = +1;
		sideDistZ = (mapZ + 1.0 - cam.z) * deltaDistZ;
	}
	
	var hit = false;
	var iters = 0;
	var abort = false;
	
	var side = 0;
	
	while (true) {
		if (sideDistY < sideDistX) {
			if (sideDistZ < sideDistY) {
				mapZ += stepZ;
				sideDistZ += deltaDistZ;
				side = 2;
			} else {
				mapY += stepY;
				sideDistY += deltaDistY;
				side = 1;
			}
		} else {
			if (sideDistZ < sideDistX) {
				mapZ += stepZ;
				sideDistZ += deltaDistZ;
				side = 2;
			} else {
				mapX += stepX;
				sideDistX += deltaDistX;
				side = 0;
			}
		}
		if (!world.inside(mapX, mapY, mapZ)) {
			if (mapX < 0 && rayDirX < 0) {
				return [bccol[0], bccol[1], bccol[2], 100];
			}
			if (mapY < 0 && rayDirY < 0) {
				return [bccol[0], bccol[1], bccol[2], 100];
			}
			if (mapZ < 0 && rayDirZ < 0) {
				return [bccol[0], bccol[1], bccol[2], 100];
			}
			if (mapX > xSiz - 1 && rayDirX > 0) {
				return [bccol[0], bccol[1], bccol[2], 100];
			}
			if (mapY > ySiz - 1 && rayDirY > 0) {
				return [bccol[0], bccol[1], bccol[2], 100];
			}
			if (mapZ > zSiz - 1 && rayDirZ > 0) {
				return [bccol[0], bccol[1], bccol[2], 100];
			}
			if (++iters > 50) {
				return [bccol[0], bccol[1], bccol[2], 100];
			}
		}
		if (world[mapX][mapY][mapZ].value > 0) {
			var perpWallDist;
			var whichFace;
			var wallX, wallY;
			
			var dx = mapX - cam.x + (1 - stepX) / 2;
			var dy = mapY - cam.y + (1 - stepY) / 2;
			var dz = mapZ - cam.z + (1 - stepZ) / 2;
			
			var dside2 = +1;
			
			if (side === 0) {
				perpWallDist = dx / rayDirX;
				dside2 = rayDirX > 0;
			} else if (side === 1) {
				perpWallDist = dy / rayDirY;
				dside2 = rayDirY > 0;
			} else {
				perpWallDist = dz / rayDirZ;
				dside2 = rayDirZ > 0;
			}
			
			var hitX = cam.x + perpWallDist * rayDirX;
			var hitY = cam.y + perpWallDist * rayDirY;
			var hitZ = cam.z + perpWallDist * rayDirZ;
			
			var lightX = mapX;
			var lightY = mapY;
			var lightZ = mapZ;
			if (side === 0) {
				if (rayDirX > 0) {
					lightX -= 1;
				} else {
					lightX += 1;
				}
			} else if (side === 1) {
				if (rayDirY > 0) {
					lightY -= 1;
				} else {
					lightY += 1;
				}
			} else {
				if (rayDirZ > 0) {
					lightZ -= 1;
				} else {
					lightZ += 1;
				}
			}
			var shade = world.getLightAt(lightX, lightY, lightZ) / 15;
			if (shade === 0) {
				shade = 1 / 30;
			}
			var wallX = 0, wallY = 0;
			
			var wh = 1;
			
			if (side === 0) {
				wallX = hitY - Math.floor(hitY);
				wallY = hitZ - Math.floor(hitZ);
				wh = 1;
			} else if (side === 1) {
				wallX = hitX - Math.floor(hitX);
				wallY = hitZ - Math.floor(hitZ);
				wh = 1;
			} else if (side === 2) {
				wallX = hitY - Math.floor(hitY);
				wallY = hitX - Math.floor(hitX);
				if (rayDirZ > 0) {
					wh = 0;
				} else {
					wh = 2;
				}
			}
			
			var whichTex = allTextures[world[mapX][mapY][mapZ].value - 1];
			
			var texX = Math.floor(wallX * 16);
			var texY = Math.floor(wallY * 16);
			
			var texL = texX + texY * 16 + wh * 256;
			
			var co = whichTex[texL];
			if (alpha(co)!==255) {
				continue;
			}
			var sh = side===0?0.75:side===1?0.90:1;
			sh *= shade;
			
			return [red(co) * sh, green(co) * sh, blue(co) * sh, perpWallDist];
		}
		if (world[mapX][mapY][mapZ].sprites.length) {
			var spriteIndex = world[mapX][mapY][mapZ].sprites[0];
			var sprite = Sprite.sprites[spriteIndex];
			
			var perpWallDist;
			var dx = mapX - cam.x + (1 - stepX) / 2;
			var dy = mapY - cam.y + (1 - stepY) / 2;
			var dz = mapZ - cam.z + (1 - stepZ) / 2;
			if (side === 0) {
				perpWallDist = dx / rayDirX;
			} else if (side === 1) {
				perpWallDist = dy / rayDirY;
			} else {
				perpWallDist = dz / rayDirZ;
			}
			var hitX = cam.x + perpWallDist * rayDirX;
			var hitY = cam.y + perpWallDist * rayDirY;
			var hitZ = cam.z + perpWallDist * rayDirZ;
			var res = sprite.castRay(hitX, hitY, hitZ, rayDirX, rayDirY, rayDirZ);
			if (res !== false) {
				return [red(res), green(res), blue(res), perpWallDist];
			}
		}
		if (++iters > 100) {
			return [bccol[0], bccol[1], bccol[2], 100];
		}
	}
};

loadPixels();
var pixels = imageData.data;

var y = 0;

draw = function () {
	var xyCt = Math.cos(cam.rotXY);
	var xySt = Math.sin(cam.rotXY);
	
	var zCt = Math.cos(cam.rotZ);
	var zSt = Math.sin(cam.rotZ);
	
	for (var x = 0; x < 400; x ++) {
		var ax = x / 400 - 0.5;
		var ay = y / 400 - 0.5;
		
		var baseRayX = 1;
		var baseRayY = ax;
		var baseRayZ = ay;
		
		// rotate Z
		var ox = baseRayX, oz = baseRayZ;
		baseRayX = zCt * ox - zSt * oz;
		baseRayZ = zCt * oz + zSt * ox;
		// rotate XY
		var ox = baseRayX, oy = baseRayY;
		baseRayX = xyCt * ox - xySt * oy;
		baseRayY = xyCt * oy + xySt * ox;
		
		
		var rdx = baseRayX;
		var rdy = baseRayY;
		var rdz = baseRayZ;
		
		var c = renderRay(rdx, rdy, rdz);
		
		var l = x + y * width << 2;
		
		if (c[3] < viewDistance) {
			pixels[l + 0] = c[0];
			pixels[l + 1] = c[1];
			pixels[l + 2] = c[2];
		} else if (c[3] < viewDistance + 20) {
			var amt = (c[3] - viewDistance) / 20;
			pixels[l + 0] = c[0] * (1 - amt) + bccol[0] * amt;
			pixels[l + 1] = c[1] * (1 - amt) + bccol[1] * amt;
			pixels[l + 2] = c[2] * (1 - amt) + bccol[2] * amt;
		} else {
			pixels[l + 0] = bccol[0];
			pixels[l + 1] = bccol[1];
			pixels[l + 2] = bccol[2];
		}
	}
	updatePixels();
	if (y < 400) {
		y ++;
	}
};
